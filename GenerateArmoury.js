/* eslint-disable */
const fs = require('fs')
const { spawnSync } = require('child_process')
const path = require('path')

const ProjectDir = process.argv[2]
if(process.argv[2] == undefined) throw `working directory is not specified (arg nr. 1)`
const ProjectName = process.argv[3]
if(process.argv[3] == undefined) throw `project name is not specified (arg nr. 2)`
const SeedNumberStr = process.argv[4] 
if(process.argv[4] == undefined) throw `seed number is not defined. it accepts in hex, octal, and base 10 (arg nr. 3)`
const SeedNumber = Number(SeedNumberStr)
if(process.argv[5] == undefined) throw `invalid seed number. it accepts in hex, octal, and base 10 (arg nr. 3)`
if(process.argv[5] == undefined) throw `Faction param (arg nr. 4) is not specified. (use | to seperate faction)`
const Factions = process.argv[5].split("|")
const LordSize = (process.argv[6]) ? Number(process.argv[6]) : 1.2
const MountSize = (process.argv[7]) ? Number(process.argv[7]) : 1.1
if(LordSize == NaN) throw `invalid number specified for LordSize (arg nr. 4)`
if(MountSize == NaN) throw `invalid number specified for MountSize (arg nr. 5)`


function ClearFolder() {
    try {
        console.log(`erasing folders...`)
        fs.rmSync(`${ProjectDir}/autogenerated/`, { recursive: true })   
    } catch (error) {
        console.log(`Folder was erased.`)
    }
}


ClearFolder()
function InitFolders() {
    console.log(`creating folders...`)
    const directory = `${ProjectDir}/autogenerated/variantmeshes/variantmeshdefinitions/autogenerated/`;
    if (!fs.existsSync(directory)) {
        fs.mkdirSync(directory, { recursive: true });
    }
    const directory2 = `${ProjectDir}/autogenerated/db/campaign_character_art_sets_tables/`;
    if (!fs.existsSync(directory2)) {
        fs.mkdirSync(directory2, { recursive: true });
    }
    const directory3 = `${ProjectDir}/autogenerated/ui/portraits/portholes/`;
    if (!fs.existsSync(directory3)) {
        fs.mkdirSync(directory3, { recursive: true });
    }
    const directory4 = `${ProjectDir}/autogenerated/ui/portraits/units/`;
    if (!fs.existsSync(directory4)) {
        fs.mkdirSync(directory4, { recursive: true });
    }
    const directory5 = `${ProjectDir}/autogenerated/db/agent_uniforms_tables/`;
    if (!fs.existsSync(directory5)) {
        fs.mkdirSync(directory5, { recursive: true });
    }
    const directory6 = `${ProjectDir}/autogenerated/db/variants_tables/`;
    if (!fs.existsSync(directory6)) {
        fs.mkdirSync(directory6, { recursive: true });
    }
    const directory7 = `${ProjectDir}/autogenerated/db/campaign_character_arts_tables/`;
    if (!fs.existsSync(directory7)) {
        fs.mkdirSync(directory7, { recursive: true });
    }
    const directory8 = `${ProjectDir}/autogenerated/campaign/mod/`;
    if (!fs.existsSync(directory8)) {
        fs.mkdirSync(directory8, { recursive: true });
    }
}

function GetAllAvailableAssets() {
    const csv = fs.readFileSync(`${ProjectDir}/AssetIdsToTheActualAssetFilenames.csv`, 'utf-8').replace(/\r/g, "")
    const lines = csv.split("\n")
    const headers = lines[0].split(",")

    const result = lines.slice(1).reduce((acc, line) => {
        const values = line.split(",")
        const obj = {}
        headers.forEach((header, i) => {
            obj[header] = values[i]
        })
        acc[obj.AssetId] = obj.AssetPath
        return acc
    }, {})

    return result
}

const AVAILABLE_ASSETS = GetAllAvailableAssets()

function GetBasicArmourSet() {
    const csv = fs.readFileSync(`${ProjectDir}/FaceAndBasicLooks.csv`, 'utf-8').replace(/\r/g, "")
    
    const lines = csv.split('\n')
    const headers = lines[0].split(',')

    const result = {};
    headers.forEach(header => {
        result[header] = []
    })

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',')
        headers.forEach((header, index) => {
            result[header].push(values[index])
        })
    }
    return result

}

//console.lo(gGetArmoursAndWeaponsLists())


function GetFaceToCampaignAnimations() {
    const csv = fs.readFileSync(`${ProjectDir}/FaceToCampaignAnimations.csv`, 'utf-8').replace(/\r/g, "")
    const rows = csv.split("\n")
    const result = {}
    
    for (let i = 1; i < rows.length; i++) {
        const values = rows[i].split(",")
        const currentFaceId = values[0]
        result[currentFaceId] = {
            LandAnimation: values[1],
            SeaAnimation: values[2],
            NavyAnimation: values[3],
            SeaUniform: values[4],
            NavyUniform: values[5],
        }
       
    }
    
    return result
}

const ANIMATIONS = GetFaceToCampaignAnimations()

function GetAssetIdToAnciliaryKeys() {
    const csv = fs.readFileSync(`${ProjectDir}/AssetIdsToTheActualAnciliaryKeys.csv`, 'utf-8').replace(/\r/g, "")
    const rows = csv.split("\n")
    const result = {}
    
    for (let i = 1; i < rows.length; i++) {
        const values = rows[i].split(",")
        const currentAssetId = values[0]
        if(result[currentAssetId] == undefined) {
            result[currentAssetId] = []
        }
        result[currentAssetId].push(values[1])
    }
    
    return result
}

const ASSET_IDS_TO_ANCILIARY_KEYS = GetAssetIdToAnciliaryKeys()

function AgentSubtypeToIncompatibleAnciliaryKey() {
    const csv = fs.readFileSync(`${ProjectDir}/AgentSubtypesToIncompatibleAnciliaryKeys.csv`, 'utf-8').replace(/\r/g, "")
    const rows = csv.split("\n")
    const result = {}
    const asset2items = GetAssetIdToAnciliaryKeys()
    const items = new Set()
    for (const key in asset2items) {
        for (const item of asset2items[key]) {
            items.add(item)
        }
    }
    
    for (let i = 1; i < rows.length; i++) {
        const values = rows[i].split(",")
        const currentSubtype = values[0]        
        if(result[currentSubtype] == undefined) {
            result[currentSubtype] = []
        }
        if(!items.has(values[1])) 
            throw `AgentSubtypesToIncompatibleAnciliaryKeys.csv this ${values[1]} anciliary is not defined in AssetIdsToTheActualAnciliaryKeys.csv`
        result[currentSubtype].push(values[1])
    }
    
    return result
}

function GetThumbnailsFromFaceIds() {
    const data = GetBasicArmourSet()   
    
    const rows = data["FaceId"].length
    const result = {}
    for (let i = 0; i < rows; i++) {
        const row = {
            Thumbnail: data.Thumbnail[i],
            ThumbnailMask1: data.ThumbnailMask1[i],
            ThumbnailMask2: data.ThumbnailMask2[i],
        };
        result[data.FaceId[i]] = row
    }
    return result
}

const FACE_ID_TO_THUMBNAILS = GetThumbnailsFromFaceIds()

function GetArmours() {
    const basicArmourSet = GetBasicArmourSet()

    const csv = fs.readFileSync(`${ProjectDir}/ListOfArmours.csv`, 'utf-8').replace(/\r/g, "")
    
    const lines = csv.split('\n')
    const headers = lines[0].split(',')

    const result = {};
    headers.forEach(header => {
        result[header] = []
    })

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',')
        headers.forEach((header, index) => {
            if(index > 0 && basicArmourSet[header].includes(values[index])) {
                throw `${values[index]} should not be put in ListOfArmours.csv`
            }
            result[header].push(values[index])
        })
    }

    return result
}

function GetHelmets() {
    const basicArmourSet = GetBasicArmourSet()

    const csv = fs.readFileSync(`${ProjectDir}/ListOfHelmets.csv`, 'utf-8').replace(/\r/g, "")
    
    const lines = csv.split('\n')
    const headers = lines[0].split(',')

    const result = {};
    headers.forEach(header => {
        result[header] = []
    })

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',')
        headers.forEach((header, index) => {
            if(index > 0 && basicArmourSet[header].includes(values[index])) {
                throw `${values[index]} should not be put in ListOfHelmets.csv`
            }
            result[header].push(values[index])
        })
    }

    return result
}

function GetWeapons() {
    const basicArmourSet = GetBasicArmourSet()

    const csv = fs.readFileSync(`${ProjectDir}/ListOfWeapons.csv`, 'utf-8').replace(/\r/g, "")
    
    const lines = csv.split('\n')
    const headers = lines[0].split(',')

    const result = {};
    headers.forEach(header => {
        result[header] = []
    })

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',')
        headers.forEach((header, index) => {
            if(index > 0 && basicArmourSet[header].includes(values[index])) {
                throw `${values[index]} should not be put in ListOfWeapons.csv`
            }
            result[header].push(values[index])
        })
    }

    return result
}

function GetShields() {
    const basicArmourSet = GetBasicArmourSet()

    const csv = fs.readFileSync(`${ProjectDir}/ListOfShields.csv`, 'utf-8').replace(/\r/g, "")
    
    const lines = csv.split('\n')
    const headers = lines[0].split(',')

    const result = {};
    headers.forEach(header => {
        result[header] = []
    })

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',')
        headers.forEach((header, index) => {
            if(index > 0 && basicArmourSet[header].includes(values[index])) {
                throw `${values[index]} should not be put in ListOfShields.csv`
            }
            result[header].push(values[index])
        })
    }

    return result
}

function GetSubtypeToArmours() {
    const data = GetArmours()
    const result = {}
    for (let i = 0; i < data.ArmourId.length; i++) {
        const AgentSubType = data.AgentSubType[i]
        const value = data.ArmourId[i]
        if(AgentSubType == "") continue
        if(result[AgentSubType] == undefined) {
            result[AgentSubType] = []
        }
        result[AgentSubType].push(value)
    }
    return result
}

function GetSubytpeToHelmets() {
    const data = GetHelmets()
    const result = {}
    for (let i = 0; i < data.HelmetId.length; i++) {
        const AgentSubType = data.AgentSubType[i]
        const value = data.HelmetId[i]
        if(AgentSubType == "") continue
        if(result[AgentSubType] == undefined) {
            result[AgentSubType] = []
        }
        result[AgentSubType].push(value)
    }
    return result
}

function GetSubytpeToShields() {
    const data = GetShields()
    const result = {}
    for (let i = 0; i < data.ShieldId.length; i++) {
        const AgentSubType = data.AgentSubType[i]
        const value = data.ShieldId[i]
        if(AgentSubType == "") continue
        if(result[AgentSubType] == undefined) {
            result[AgentSubType] = []
        }
        result[AgentSubType].push(value)
    }
    return result
}

function GetSubytpeToWeapons() {
    const data = GetWeapons()
    const result = {}
    for (let i = 0; i < data.WeaponId.length; i++) {
        const AgentSubType = data.AgentSubType[i]
        const value = data.WeaponId[i]
        if(AgentSubType == "") continue
        if(result[AgentSubType] == undefined) {
            result[AgentSubType] = []
        }
        result[AgentSubType].push(value)
    }
    return result
}

function GetConflictingAnciliaries() {
    
    const csv = fs.readFileSync(`${ProjectDir}/IncompatibleAnciliaries.csv`, 'utf-8').replace(/\r/g, "")
    
    const lines = csv.split('\n')
    if(lines.length == 1) return {}

    const result = {}
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i]
        const keyValue = line.split(",")
        const key = keyValue[0]
        const value = keyValue[1]
        if(result[key] == undefined) {
            result[key] = []
        }
        result[key].push(value)
    }
    return result
}

function GenerateBasicArmourySetIds() {
    const data = GetBasicArmourSet()   
    
    const rows = data["FaceId"].length
    const result = []
    for (let i = 0; i < rows; i++) {
        const row = {
            FaceId: data.FaceId[i],
            HelmetId: data.HelmetId[i],
            ArmourId: data.ArmourId[i],
            WeaponId: data.WeaponId[i],
            ShieldId: data.ShieldId[i],
        };
        result.push(`ArmourySystem__${row.FaceId}__${row.HelmetId}__${row.ArmourId}__${row.WeaponId}__${row.ShieldId}`);
    }
    return result
}


function GenerateCombinations() {
    console.log(`Compiling csvs...`)
    console.time('GenerateCombinations')
    const basicSet = GetBasicArmourSet()
    const basicCombinations = GenerateBasicArmourySetIds()

    const helmets = GetHelmets().HelmetId.concat(basicSet.HelmetId)
    const helmetsAndSubtype = GetHelmets()
    const armours = GetArmours().ArmourId.concat(basicSet.ArmourId)
    const armoursAndSubtype = GetArmours()
    const weapons = GetWeapons().WeaponId.concat(basicSet.WeaponId)
    const weaponsAndSubtype = GetWeapons()
    const shields = GetShields().ShieldId.concat(basicSet.ShieldId)
    const shieldsAndSubtype = GetShields()

    const weaponCompatibleCache = {}
    function IsWeaponCompatible(faceId, weaponIdToSearch) {
        if(weaponCompatibleCache[faceId] && weaponCompatibleCache[faceId][weaponIdToSearch]) 
            return true
        if(weaponCompatibleCache[faceId] && weaponCompatibleCache[faceId][weaponIdToSearch] == false)
            return false

        const faceIdx = basicSet.FaceId.indexOf(faceId)
        const basicWeaponId = basicSet.WeaponId[faceIdx]
        if(weaponIdToSearch == basicWeaponId) return true
        
        const AgentSubType = basicSet.AgentSubType[faceIdx]
        for (let i = 0; i < weaponsAndSubtype.AgentSubType.length; i++) {
            const agentSubtypeWeapon = weaponsAndSubtype.AgentSubType[i]
            const weaponId = weaponsAndSubtype.WeaponId[i]
            if(agentSubtypeWeapon == AgentSubType && weaponId == weaponIdToSearch) {
                weaponCompatibleCache[faceId] = {}
                weaponCompatibleCache[faceId][weaponIdToSearch] = true
                return true
            }
        }
        weaponCompatibleCache[faceId] = {}
        weaponCompatibleCache[faceId][weaponIdToSearch] = false
        return false
    }

    
    const armourCompatibleCache = {}
    function IsArmourCompatible(faceId, armourIdToSearch) {
        if(armourCompatibleCache[faceId] && armourCompatibleCache[faceId][armourIdToSearch]) 
            return true
        if(armourCompatibleCache[faceId] && armourCompatibleCache[faceId][armourIdToSearch] == false)
            return false

        const faceIdx = basicSet.FaceId.indexOf(faceId)
        const armourId = basicSet.ArmourId[faceIdx]
        if(armourIdToSearch == armourId) return true

        const AgentSubType = basicSet.AgentSubType[faceIdx]
        for (let i = 0; i < armoursAndSubtype.AgentSubType.length; i++) {
            const agentSubtypeArmour = armoursAndSubtype.AgentSubType[i]
            const armourId = armoursAndSubtype.ArmourId[i]
            if(agentSubtypeArmour == AgentSubType && armourId == armourIdToSearch)  {
                armourCompatibleCache[faceId] = {}
                armourCompatibleCache[faceId][armourIdToSearch] = true
                return true
            }
        }
        armourCompatibleCache[faceId] = {}
        armourCompatibleCache[faceId][armourIdToSearch] = false
        return false
    }

    const helmetCompatibleCache = {}
    function IsHelmetCompatible(faceId, helmetIdToSearch) {
        if(helmetCompatibleCache[faceId] && helmetCompatibleCache[faceId][helmetIdToSearch]) 
            return true
        if(helmetCompatibleCache[faceId] && helmetCompatibleCache[faceId][helmetIdToSearch] == false)
            return false

        const faceIdx = basicSet.FaceId.indexOf(faceId)
        const helmetId = basicSet.HelmetId[faceIdx]
        if(helmetIdToSearch == helmetId) return true

        const AgentSubType = basicSet.AgentSubType[faceIdx]
        for (let i = 0; i < helmetsAndSubtype.AgentSubType.length; i++) {
            const agentSubtypeHelmet = helmetsAndSubtype.AgentSubType[i]
            const helmetId = helmetsAndSubtype.HelmetId[i]
            if(agentSubtypeHelmet == AgentSubType && helmetId == helmetIdToSearch) {
                helmetCompatibleCache[faceId] = {}
                helmetCompatibleCache[faceId][helmetIdToSearch] = true
                return true
            }
        }        
        helmetCompatibleCache[faceId] = {}
        helmetCompatibleCache[faceId][helmetIdToSearch] = false
        return false
    }

    const shieldCompatibleCache = {}
    function IsShieldCompatible(faceId, shieldIdToSearch) {
        if(shieldCompatibleCache[faceId] && shieldCompatibleCache[faceId][shieldIdToSearch]) 
            return true
        if(shieldCompatibleCache[faceId] && shieldCompatibleCache[faceId][shieldIdToSearch] == false)
            return false
            
        if(!IsAgentSupportShield(faceId)) return false
        if(shieldIdToSearch == "NONE") return false

        const faceIdx = basicSet.FaceId.indexOf(faceId)
        const shieldId = basicSet.ShieldId[faceIdx]
        if(shieldIdToSearch == shieldId) return true

        const AgentSubType = basicSet.AgentSubType[faceIdx]
        for (let i = 0; i < shieldsAndSubtype.AgentSubType.length; i++) {
            const agentSubtypeShield = shieldsAndSubtype.AgentSubType[i]
            const shieldId = shieldsAndSubtype.ShieldId[i]
            if(agentSubtypeShield == AgentSubType && shieldId == shieldIdToSearch)  {
                shieldCompatibleCache[faceId] = {}
                shieldCompatibleCache[faceId][shieldIdToSearch] = true
                return true
            }
        }
        shieldCompatibleCache[faceId] = {}
        shieldCompatibleCache[faceId][shieldIdToSearch] = false
        return false
    }

    function IsAgentSupportShield(faceId) {
        const faceIdx = basicSet.FaceId.indexOf(faceId)
        return basicSet.ShieldId[faceIdx] != "NONE"
        
    }

    const result = []
    let totalPruned = 0
    let counter = 0
    for (const face of basicSet.FaceId) {
        for (const helmet of helmets) {
            if(!IsHelmetCompatible(face, helmet)) {
                totalPruned++
                continue
            }

            for (const armour of armours) {
                if(!IsArmourCompatible(face, armour)) {
                    totalPruned++
                    continue
                }

                for (let shield of shields) {
                    if(IsAgentSupportShield(face) && !IsShieldCompatible(face, shield)) {
                        totalPruned++
                        continue
                    }

                    for (const weapon of weapons) {

                        if(!IsWeaponCompatible(face, weapon)){
                            totalPruned++
                            continue
                        }  
                        
                        const isSupportsShield = IsAgentSupportShield(face)
                        if(!isSupportsShield) {
                            shield = "NONE"
                        }
                        const x = `ArmourySystem__${face}__${helmet}__${armour}__${weapon}__${shield}`
                        if(basicCombinations.indexOf(x) >= 0) continue
                        if(result.indexOf(x) >= 0) continue
                        result.push(x)
                        counter++
                        process.stdout.write(`\rProcessing ${counter}. Pruned: ${totalPruned} => ${face} ${helmet} ${armour} ${shield} ${weapon}       `)
                    }
                }
            }
        }   
    }
    
    console.log("")
    const total = basicSet.FaceId.length * helmets.length * armours.length * weapons.length * shields.length
    console.log(`GenerateCombinations: pruned impossible path ${totalPruned} generated ${result.length} without prunning ${ total } reduction is ${ ((total - result.length) / total) * 100 } %`)
    console.timeEnd('GenerateCombinations')
    return result
}

let BASIC_IDS = null
let COMBINATION_IDS = null

function StartCsvCompiler() {
    BASIC_IDS = GenerateBasicArmourySetIds()
    COMBINATION_IDS = GenerateCombinations()
}

function GenerateXMLFromIds(xmlname) {
    const basicIds = BASIC_IDS
    const combinationsIds = COMBINATION_IDS

    console.log(`Generating thumbnails xml...`)
    //generate thumbnails with basic armour
    let entries = `
    <!-- BASIC THUMBNAILS STARTS HERE -->
    `
    for (const id of basicIds) {
        const faceId = id.split("__")[1]
        const thumbnail = FACE_ID_TO_THUMBNAILS[faceId]
        if(thumbnail == undefined) {
            throw `this faceid ${faceId} has no thumbnail!`
        }
        const entry = `
        <Entry id="${id}">
            <CameraSettings>
                <Distance_Head>0.8</Distance_Head>
                <Theta_Head>0</Theta_Head>
                <Phi_Head>0</Phi_Head>
                <FoV_Head>0</FoV_Head>
                <Distance_2>30</Distance_2>
                <Distance_Body>4</Distance_Body><!--optional-->
                <Theta_Body>0</Theta_Body><!--optional-->
                <Phi_Body>0</Phi_Body><!--optional-->
                <FoV_Body>0</FoV_Body><!--optional-->
                <Distance_2_Body>30</Distance_2_Body><!--optional-->
            </CameraSettings>
        <Variants>
			<Variant id="${id}">
                <FileDiffuse>${thumbnail.Thumbnail}</FileDiffuse>
                <FileMask1>${thumbnail.ThumbnailMask1 ?? ""}</FileMask1> <!--All three masks are optional-->
                <FileMask2>${thumbnail.ThumbnailMask2 ?? ""}</FileMask2>	<!--All three masks are optional-->
                <FileMask3></FileMask3>	<!--All three masks are optional-->
            </Variant>
        </Variants>
        </Entry>
        `
        entries += entry
    }
    entries += `
    <!-- BASIC THUMBNAILS ENDS HERE -->
    `

    for (const combinationId of combinationsIds) {
        const faceId = combinationId.split("__").slice(0, 2).join("__")
        const basicId = basicIds.find( id => id.includes(faceId) )
        const faceIdOnly = combinationId.split("__")[1]
        const thumbnail = FACE_ID_TO_THUMBNAILS[faceIdOnly]
        if(thumbnail == undefined) {
            throw `FaceAndBasicLooks.csv this faceid ${faceIdOnly} has no thumbnail!`
        }
        const entry = `
        <Entry id="${combinationId}">
            <CameraSettings>
                <Distance_Head>0.8</Distance_Head>
                <Theta_Head>0</Theta_Head>
                <Phi_Head>0</Phi_Head>
                <FoV_Head>0</FoV_Head>
                <Distance_2>30</Distance_2>
                <Distance_Body>4</Distance_Body><!--optional-->
                <Theta_Body>0</Theta_Body><!--optional-->
                <Phi_Body>0</Phi_Body><!--optional-->
                <FoV_Body>0</FoV_Body><!--optional-->
                <Distance_2_Body>30</Distance_2_Body><!--optional-->
            </CameraSettings>
        <Variants>
			<Variant id="${combinationId}">
                <FileDiffuse>${thumbnail.Thumbnail}</FileDiffuse>
                <FileMask1>${thumbnail.ThumbnailMask1 ?? ""}</FileMask1> <!--All three masks are optional-->
                <FileMask2>${thumbnail.ThumbnailMask2 ?? ""}</FileMask2>	<!--All three masks are optional-->
                <FileMask3></FileMask3>	<!--All three masks are optional-->
            </Variant>
        </Variants>
        </Entry>
        `
        entries += entry
    }

    const template = `
    <?xml version="1.0" encoding="UTF-8"?>
    <PortraitSettings version="4">
        ${entries}
    </PortraitSettings>
    `

    fs.writeFileSync(`${ProjectDir}/autogenerated/ui/portraits/portholes/portrait_settings__autogenerated_${xmlname}.xml`, template)
    fs.writeFileSync(`${ProjectDir}/autogenerated/ui/portraits/units/portrait_settings__autogenerated_${xmlname}.xml`, template)
    spawnSync('Selfiehammer.exe', [`${ProjectDir}/autogenerated/ui/portraits/portholes/portrait_settings__autogenerated_${xmlname}.xml`])
    spawnSync('Selfiehammer.exe', [`${ProjectDir}/autogenerated/ui/portraits/units/portrait_settings__autogenerated_${xmlname}.xml`])
}

//campaign_character_art_sets_tables
function GenerateCampaignCharacterArtSetsTables(tableName) {
    const basicArmourSet =  GetBasicArmourSet()
    const basicIds = BASIC_IDS
    const combinationsIds = COMBINATION_IDS

    console.log(`Generating campaign_character_art_sets_tables`)

    let   header = `art_set_id	agent_type	culture	subculture	faction	is_custom	is_male	agent_subtype	campaign_map_scale\n`
          header+= `#campaign_character_art_sets_tables;6;db/campaign_character_art_sets_tables/@@@autogenerated_${tableName}								`

    
    //basic looks thumbnail db entries
    let entries = ``
    for (const basicId of basicIds) {
        const faceId = basicId.split("__")[1]
        const index = basicArmourSet.FaceId.indexOf(faceId)
        const entry = `${basicId}\t${basicArmourSet.AgentType[index]}\t${basicArmourSet.Culture[index]}\t\t\tfalse\ttrue\t${basicArmourSet.AgentSubType[index]}\t1.000\n`
        entries += entry
    }

    //customisable armours db entries
    for (const combinationId of combinationsIds) {
        const faceId = combinationId.split("__")[1]
        const index = basicArmourSet.FaceId.indexOf(faceId)
        const entry = `${combinationId}\t${basicArmourSet.AgentType[index]}\t${basicArmourSet.Culture[index]}\t\t\tfalse\ttrue\t${basicArmourSet.AgentSubType[index]}\t1.000\n`
        entries += entry
    }

    const tsv = `${header}\n${entries}`
    fs.writeFileSync(`${ProjectDir}/autogenerated/db/campaign_character_art_sets_tables/@@@autogenerated_${tableName}.tsv`, tsv)
}

function GenerateUniforms(tableName) {
    const basicIds = BASIC_IDS
    const combinationsIds = COMBINATION_IDS

    console.log(`Generating agent_uniforms_tables`)

    let header = `uniform_name	filename	battle_filename	campaign_porthole_filename	campaign_politician_filename	campaign_override_skeleton\n`
       header += `#agent_uniforms_tables;10;db/agent_uniforms_tables/@@@autogenerated_${tableName}	`

    let entries = `` 
    const combinedIds = basicIds.concat(combinationsIds)
    for (const id of combinedIds) {
        entries += `${id}\t${id}\t${id}\t${id}\t\t\n`
    }

    const tsv=`${header}\n${entries}`
    fs.writeFileSync(`${ProjectDir}/autogenerated/db/agent_uniforms_tables/@@@autogenerated_${tableName}.tsv`, tsv)
}

function GenerateVariantTables(tableName, scale, mountScale) {
    console.log(`Generating variants_tables`)

    const basicIds = BASIC_IDS
    const combinationsIds = COMBINATION_IDS

    let header = `variant_name	tech_folder	variant_filename	low_poly_filename	mount_scale	scale	scale_variation	super_low_poly_filename\n`
       header += `#variants_tables;6;db/variants_tables/@@@autogenerated_${tableName}							`
    
    let entries = `` 
    const combinedIds = basicIds.concat(combinationsIds)
    for (const id of combinedIds) {
        if( `variantmeshes/variantmeshdefinitions/${id}`.length >= 255 ) {
            throw `${id} is too long. This will crash the game due to long path (max 255). Path: variantmeshes/variantmeshdefinitions/${id}`
        }
        entries += `${id}\t\tautogenerated/${id}\t\t${mountScale}\t${scale}\t0\t\n`
    }

    const tsv=`${header}\n${entries}`
    fs.writeFileSync(`${ProjectDir}/autogenerated/db/variants_tables/@@@autogenerated_${tableName}.tsv`, tsv)
}

function GenerateCampaignCharacterArtsTables(tableName, seedNumber) {
    console.log(`Generating campaign_character_arts_tables`)

    const basicIds = BASIC_IDS
    const combinationsIds = COMBINATION_IDS

    let header = `id	art_set_id	level	age	portrait	season	uniform	card	info	sea_uniform	navy_uniform	land_animation	sea_animation	navy_animation	land_animation_vfx_filter	sea_animation_vfx_filter	navy_animation_vfx_filter\n`
        header += `#campaign_character_arts_tables;0;db/campaign_character_arts_tables/@@@autogenerated_${tableName}																`
    
    const combinedIds = basicIds.concat(combinationsIds)
    let entries = ``
    for (const id of combinedIds) {
        const faceId = id.split("__")[1]
        const animation = ANIMATIONS[faceId]
        if(!animation) {
            throw `FaceToCampaignAnimations.csv ${faceId} has undefined animation`
        }
        if(animation.LandAnimation == undefined) {
            throw `FaceToCampaignAnimations.csv ${faceId} has undefined Land animation`
        }
        if(animation.SeaAnimation == undefined) {
            throw `FaceToCampaignAnimations.csv ${faceId} has undefined Sea animation`
        }
        if(animation.NavyAnimation == undefined) {
            throw `FaceToCampaignAnimations.csv ${faceId} has undefined Navy animation`
        }
        if(animation.SeaUniform == undefined) {
            throw `FaceToCampaignAnimations.csv ${faceId} has undefined Sea uniform`
        }
        if(animation.NavyUniform == undefined) {
            throw `FaceToCampaignAnimations.csv ${faceId} has undefined Navy uniform`
        }

        entries += `${seedNumber}\t${id}\t0\t0\t\tnone\t${id}\t\t\t${animation.SeaUniform}\t${animation.NavyUniform}\t${animation.LandAnimation}\t${animation.SeaAnimation}\t${animation.NavyAnimation}\t0\t0\t0\n`
        seedNumber++
    }    

    const tsv=`${header}\n${entries}`
    fs.writeFileSync(`${ProjectDir}/autogenerated/db/campaign_character_arts_tables/@@@autogenerated_${tableName}.tsv`, tsv)
}

function GenerateVariantMeshDefinitions() {
    const basicIds = BASIC_IDS
    const combinationsIds = COMBINATION_IDS

    console.log(`Generating Variantmesh definitions...`)
    const ids = basicIds.concat(combinationsIds)
    let counter = 0
    let length = ids.length
    for (const id of ids) {
        const split = id.split("__")
        const components = {
            FaceId: split[1],
            HelmetId: split[2],
            ArmourId: split[3],
            WeaponId: split[4],
            ShieldId: split[5],
        }
        if(!AVAILABLE_ASSETS[components.FaceId]) {
            throw(`${components.FaceId} is not defined in AssetIdsToTheActualAssetFilename.csv`)
        }
        if(!AVAILABLE_ASSETS[components.HelmetId]) {
            throw(`${components.HelmetId} is not defined in AssetIdsToTheActualAssetFilename.csv`)
        }
        if(!AVAILABLE_ASSETS[components.ArmourId]) {
            throw(`${components.ArmourId} is not defined in AssetIdsToTheActualAssetFilename.csv`)
        }
        if(!AVAILABLE_ASSETS[components.WeaponId]) {
            throw(`${components.WeaponId} is not defined in AssetIdsToTheActualAssetFilename.csv`)
        }
        if(!AVAILABLE_ASSETS[components.ShieldId]) {
            throw(`${components.ShieldId} is not defined in AssetIdsToTheActualAssetFilename.csv`)
        }

        const twoHandedWeapon = (components.ShieldId == "NONE") ? AVAILABLE_ASSETS[components.WeaponId] : ""
        const oneHandedWeapon = (components.ShieldId != "NONE") ? AVAILABLE_ASSETS[components.WeaponId] : ""
        const shieldWeapon    = (components.ShieldId != "NONE") ? AVAILABLE_ASSETS[components.ShieldId] : ""
        const audioMetaShield = (components.ShieldId != "NONE") ? "audio_shield_type:metal" : ""
        const audioMetaSword  = (components.ShieldId != "NONE") ? "audio_melee_weapon_type:sword" : ""
        const audioMetaAxe    = (components.ShieldId == "NONE") ? "audio_melee_weapon_type:axe" : ""
        const entry = `
<VARIANT_MESH>
    <SLOT name="head" >
        <VARIANT_MESH model="${AVAILABLE_ASSETS[components.FaceId]}">
            <META_DATA>audio_entity_type:wh_human_male_bret_french</META_DATA>
            <META_DATA>audio_armour_type:plate</META_DATA>
        </VARIANT_MESH>
    </SLOT>
    <SLOT name="crest" >
        <VARIANT_MESH model="${AVAILABLE_ASSETS[components.HelmetId]}" />
    </SLOT>
    <SLOT name="cape">
        
    </SLOT>
    <SLOT name="body" >
        <VARIANT_MESH model="${AVAILABLE_ASSETS[components.ArmourId]}">
            <META_DATA>audio_entity_type:wh_human_male_bret_french</META_DATA>
            <META_DATA>audio_armour_type:plate</META_DATA>
        </VARIANT_MESH>
    </SLOT>
    <SLOT name="weapon_1" attach_point="be_prop_0" >
        <VARIANT_MESH model="${twoHandedWeapon}">
            <META_DATA>${audioMetaAxe}</META_DATA>
        </VARIANT_MESH>
    </SLOT>
    <SLOT name="weapon_2" attach_point="be_prop_1">
        <VARIANT_MESH model="${oneHandedWeapon}">
            <META_DATA>${audioMetaSword}</META_DATA>
        </VARIANT_MESH>
    </SLOT>
    <SLOT name="shield" attach_point="be_prop_2" >
        <VARIANT_MESH model="${shieldWeapon}">
            <META_DATA>${audioMetaShield}</META_DATA>
        </VARIANT_MESH>
    </SLOT>
    <SLOT name="weapon_3" attach_point="be_prop_3" />
    <SLOT name="weapon_4" attach_point="be_prop_4" />
    <SLOT name="weapon_5" attach_point="be_prop_5" />
</VARIANT_MESH>    
        `
        fs.writeFileSync(`${ProjectDir}/autogenerated/variantmeshes/variantmeshdefinitions/autogenerated/${id}.variantmeshdefinition`, entry)
        counter++
        process.stdout.write(`\rProcessing: ${counter} of ${length}`)
    }
    console.log("")
}

function GenerateTypescriptArmouryData(projectName, factions) {
    console.log("compiling csv into typescript data")

    const subtypeAgentKeys = new Set(GetBasicArmourSet().AgentSubType)

    function ArmoryData() {
        const armourset = GetBasicArmourSet()
        const rows = armourset.FaceId.length
        let generatedBasicSet = ``
        for (let i = 0; i < rows; i++) {
            const template = `
            ["${armourset.Thumbnail[i]}"] : {
                FaceId: "${armourset.FaceId[i]}",
                HelmetId: "${armourset.HelmetId[i]}",
                ArmourId: "${armourset.ArmourId[i]}",
                WeaponId: "${armourset.WeaponId[i]}",
                ShieldId: "${armourset.ShieldId[i]}",
            },`
            generatedBasicSet += template
        }

        return generatedBasicSet
    }

    function Factions() {
        return JSON.stringify(factions)
    }

    function AgentSubTypes() {
        return JSON.stringify(Array.from(subtypeAgentKeys.values()))
    }

    function RegisteredArmours() {
        const subTypes = GetSubtypeToArmours()
        let entries = ``
        for (const subType in subTypes) {
            for (const armour of subTypes[subType]) {
                const anciliaryKeys = ASSET_IDS_TO_ANCILIARY_KEYS[armour]
                if(anciliaryKeys == undefined || anciliaryKeys.length == 0) {
                    throw `AssetId ${armour} is not defined in AssetIdsToTheActualAnciliaryKeys.csv`
                }
                for(const anciliaryKey of anciliaryKeys) {
                    const entry = `{
                        anciliaryKey: "${anciliaryKey}",
                        subtypeAgentKey: "${subType}",
                        assetId: "${armour}"
                    },`
                    entries += entry
                }
            }
        }

        return entries
    }

    function RegisteredHelmets() {
        const subTypes = GetSubytpeToHelmets()
        let entries = ``
        for (const subType in subTypes) {
            for (const helmet of subTypes[subType]) {
                const anciliaryKeys = ASSET_IDS_TO_ANCILIARY_KEYS[helmet]
                if(anciliaryKeys.length == 0) {
                    throw `AssetId ${helmet} is not defined in AssetIdsToTheActualAnciliaryKeys.csv`
                }
                for(const anciliaryKey of anciliaryKeys) {
                    const entry = `{
                        anciliaryKey: "${anciliaryKey}",
                        subtypeAgentKey: "${subType}",
                        assetId: "${helmet}"
                    },`
                    entries += entry
                }
            }
        }

        return entries
    }

    function RegisteredWeapons() {
        const subTypes = GetSubytpeToWeapons()
        let entries = ``
        for (const subType in subTypes) {
            for (const weapon of subTypes[subType]) {
                const anciliaryKeys = ASSET_IDS_TO_ANCILIARY_KEYS[weapon]
                if(anciliaryKeys.length == 0) {
                    throw `AssetId ${weapon} is not defined in AssetIdsToTheActualAnciliaryKeys.csv`
                }
                for(const anciliaryKey of anciliaryKeys) {
                    const entry = `{
                        anciliaryKey: "${anciliaryKey}",
                        subtypeAgentKey: "${subType}",
                        assetId: "${weapon}"
                    },`
                    entries += entry
                }
            }
        }

        return entries
    }

    function RegisteredShields() {
        const subTypes = GetSubytpeToShields()
        let entries = ``
        for (const subType in subTypes) {
            for (const shield of subTypes[subType]) {
                const anciliaryKeys = ASSET_IDS_TO_ANCILIARY_KEYS[shield]
                if(anciliaryKeys.length == 0) {
                    throw `AssetId ${shield} is not defined in AssetIdsToTheActualAnciliaryKeys.csv`
                }
                for(const anciliaryKey of anciliaryKeys) {
                    const entry = `{
                        anciliaryKey: "${anciliaryKey}",
                        subtypeAgentKey: "${subType}",
                        assetId: "${shield}"
                    },`
                    entries += entry
                }
            }
        }
        return entries
    }

    function IncompatibleItems() {
        let entries = `//incompatible items\n\t`
        const incompatibleItems = AgentSubtypeToIncompatibleAnciliaryKey()
        for (const key in incompatibleItems) {          
            if(key == "") continue  
            const entry = `ArmourySystem.MakeThisItemIncompatibleWithAgent("${key}", ${JSON.stringify(incompatibleItems[key])})\n`
            entries += entry
        }        
        return entries
    }

    function ConflictingItems() {
        let entries = `//conflicting items\n\t`
        const conflictingItems = GetConflictingAnciliaries()
        for (const anciliary in conflictingItems) {
            if(anciliary == "") continue
            const conflictingAnciliaries = conflictingItems[anciliary]
            const entry = `ArmourySystem.MakeThisItemIncompatibleWithItems("${anciliary}", ${JSON.stringify(conflictingAnciliaries)})\n`
            entries += entry
        }
        return entries
    }

    const generatedBasicSet = ArmoryData()
    const generatedFactions = Factions()
    const generatedSubtypes = AgentSubTypes()
    const generatedArmours = RegisteredArmours()
    const generatedHelmets = RegisteredHelmets()
    const generatedWeapons = RegisteredWeapons()
    const generatedShields = RegisteredShields()
    const incompatibleItems = IncompatibleItems()
    const conflictingItems = ConflictingItems()
    const currentDate = new Date()
    const timestamp = currentDate.toLocaleString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric'
      })
    const source = `
namespace TheGrailLordsOfBretonnia {

    /** AUTOGENERATED TYPESCRIPT ${timestamp} */

    type ThumbnailFilenameToBasicSet = {
        [thumbnailFile: string]: ArmourySystem.BasicSet
    }

    const ARMOURY_DATA: ThumbnailFilenameToBasicSet = {
        ${generatedBasicSet}
    }

    ArmourySystem.RegisterFaction(${generatedFactions})
    ArmourySystem.RegisterSubtypeAgent(${generatedSubtypes})
    for (const [fileName, basicSet] of Object.entries(ARMOURY_DATA)) {
        ArmourySystem.RegisterThumbnailFilenamesToAssociatedBasicSet(fileName, basicSet)
    }
    ArmourySystem.RegisterArmour([
        ${generatedArmours}
    ])
    ArmourySystem.RegisterHelmet([
        ${generatedHelmets}
    ])
    ArmourySystem.RegisterWeapon([
        ${generatedWeapons}
    ])
    ArmourySystem.RegisterShield([
        ${generatedShields}
    ])

    ${incompatibleItems}
    ${conflictingItems}
}
`
    fs.writeFileSync(`${ProjectDir}/autogenerated/campaign/mod/ZZZAutoGenerated_${projectName}.ts`, source)
}

const SEED_NUMBER = SeedNumber
const LORD_SCALE = LordSize
const MOUNT_SCALE = MountSize

InitFolders()
GenerateTypescriptArmouryData(ProjectName, Factions)
StartCsvCompiler()
GenerateXMLFromIds(ProjectName)
GenerateCampaignCharacterArtSetsTables(ProjectName)
GenerateUniforms(ProjectName)
GenerateCampaignCharacterArtsTables(ProjectName, SEED_NUMBER)
GenerateVariantTables(ProjectName, LORD_SCALE, MOUNT_SCALE)
GenerateVariantMeshDefinitions()
// const packFileName = "massif_lord_assets"
// PackToFile(packFileName)